[[a2344]]
== Expression Language and Managed Bean Facility

In the descriptions of the standard user
interface component model, it was noted that all attributes, and nearly
all properties can have a _value expression_ associated with them (see
<<UserInterfaceComponentModel.adoc#a911,ValueExpression properties>>). In
addition, many properties, such as _action_, _actionListener_,
_validator_, and _valueChangeListener_ can be defined by a _method
expression_ pointing at a public method in some class to be executed.
This chapter describes the mechanisms and APIs that Jakarta Faces
utilizes in order to evaluate value expressions and method expressions.

Jakarta Faces relies on Jakarta Expression Language as described by version 4.0 of
the Jakarta Expression Language specification. 
Please consult that document for complete details about the Expression Language.

Versions 1.0 and 1.1 of pre-Jakarta Faces JSF under the JCP
included a built in expression language and required an implementation
of it. The API for this old JSF EL is still preserved as deprecated
classes and methods, and Jakarta Faces implementations must still support that API.
Please consult the <<ChangeLog.adoc#a8777,Guide to Deprecated
Methods Relating to the Expression Language and their Corresponding Replacements>>
for details. This chapter will focus exclusively on how Jakarta Faces leverages
and integrates with Jakarta Expression Language. It does not describe how Jakarta Expression Language operates.

[[a2349]]
=== Value Expressions

==== Overview

To support binding of attribute and property
of values to dynamically calculated results, the name of the attribute
or property can be associated with a value expression using the
_setValueExpression()_ method. Whenever the dynamically calculated
result of evaluating the expression is required, the _getValue()_ method
of the _ValueExpression_ is called, which returns the evaluated result.
Such expressions can be used, for example, to dynamically calculate a
component value to be displayed:

[source,xml]
----
<h:outputText value=”#{customer.name}”/>
----

which, when this page is rendered, will
retrieve the bean stored under the “customer” key, then acquire the name
property from that bean and render it.

Besides the component value itself, value
expressions can be used to dynamically compute attributes and
properties. The following example checks a _boolean_ property _manager_
on the current _user_ bean (presumably representing the logged-in user)
to determine whether the _salary_ property of an employee should be
displayed or not:

[source,xml]
----
<h:outputText rendered=”#{user.manager}” value=”#{employee.salary}”/>
----

which sets the _rendered_ property of the
component to _false_ if the user is not a manager, and therefore causes
this component to render nothing.

The Jakarta Expression Language has a
powerful set of coercion rules that automatically convert the type of
the value to the appropriate type. These rules occasionally rely on the
JavaBeans _PropertyEditor_ facility to perform this conversion. Note
that this conversion is entirely separate from normal Jakarta Faces Conversion.

Value expressions can also be used to set a
value from the user into the item obtained by evaluating the expression.
For example:

[source,xml]
----
<h:inputText value=”#{employee.number}”/>
----

When the page is rendered, the expression is
evaluated as an r-value and the result is displayed as the default value
in the text field. When the page is submitted, the expression is
evaluated as an l-value, and the value entered by the user (subject to
conversion and validation as usual) is pushed into the expression.

==== Value Expression Syntax and Semantics

Please see Section 1.2 of the Jakarta Expression
Language Specification, Version 4.0 or higher for the complete specification of
ValueExpression syntax and semantics.


=== MethodExpressions

_Method expressions_ are a very similar to
value expressions, but rather than supporting the dynamic retrieval and
setting of properties, method expressions support the invocation (i.e.
execution) of an arbitrary public method of an arbitrary object, passing
a specified set of parameters, and returning the result from the called
method (if any). They may be used in any phase of the request processing
lifecycle; the standard Jakarta Faces components and framework employ them
(encapsulated in a _MethodExpression_ object) at the following times:

* During _Apply Request Values_ or _Invoke
Application_ phase (depending upon the state of the _immediate_
property), components that implement the _ActionSource2_ behavioral
interface (see <<UserInterfaceComponentModel.adoc#a1120,ActionSource2>>) utilize
_MethodExpressions_ as follows:

** If the _actionExpression_ property is
specified, it must be a _MethodExpression_ expression that identifies an
Application Action method (see <<ApplicationIntegration.adoc#a3553,
Application Actions>>) that takes no parameters and returns a String.

** It’s possible to have a method expression act
as an _ActionListener_ by using the classs
_MethodExpressionActionListener_ to wrap a method expression and calling
the _addActionListener()_ method on the _ActionSource_. The method
expression wrapped inside the _MethodExpressionActionListener_ must
identify a public method that accepts an _ActionEvent_ (see
<<UserInterfaceComponentModel.adoc#a1308,Event Classes>>) instance, and has a
return type of _void_. The called method has exactly the same
responsibilities as the _processAction()_ method of an _ActionListener_
instance (see <<UserInterfaceComponentModel.adoc#a1329,Listener Classes>>) that
was built in to a separate Java class.

* During the _Apply Request Values_ or _Process
Validations_ phase (depending upon the state of the _immediate_
property), components that implement _EditableValueHolder_ (such as
_UIInput_ and its subclasses) components (see
<<UserInterfaceComponentModel.adoc#a1192,EditableValueHolder>>) utilize method
expressions as follows:

** The user can use the
_MethodExpressionValidator_ class to wrap a method expression that
identifies a public method that accepts a _FacesContext_ instance and a
_UIComponent_ instance, and an _Object_ containing the value to be
validated, and has a return type of _void_. This
_MethodExpressionValidator_ instance can then be added as a normal
_Validator_ using the _EditableValueHolder.addValidator()_ method. The
called method has exactly the same responsibilities as the _validate()_
method of a _Validator_ instance (see <<UserInterfaceComponentModel.adoc#a1414,
Validator Classes>>) that was built in to a separate Java class.

** The user can use the
_MethodExpressionValueChangeListener_ class to wrap a method expression
that identifies a public method that accepts a _ValueChangeEvent_ (see
<<UserInterfaceComponentModel.adoc#a1308,Event Classes>>) instance, and has a
return type of _void_. This _MethodExpressionValueChangeListener_
instance can then be added as a normal _ValueChangeListener_ using
EditableValueHolder.addValueChangeListener(). The called method has
exactly the same responsibilities as the _processValueChange()_ method
of a _ValueChangeListener_ instance (see <<UserInterfaceComponentModel.adoc#a1329,
Listener Classes>>) that was built in to a separate Java class.

Here is the set of component properties that
currently support _MethodBinding_, and the method signatures to which
they must point:

.component properties whose type is DEPRECATED MethodBinding
[width="100%",cols="25%,75%",options="header",]
|===
|component property
|method signature

|*DEPRECATED* _action_
|_public String <methodName>();_

|*DEPRECATED* _actionListener_
|_public void <methodName>(jakarta.faces.event.ActionEvent);_

|*DEPRECATED* _validator_
|_public void <methodName>(jakarta.faces.context.FacesContext,
jakarta.faces.component.UIComponent, java.lang.Object)_

|*DEPRECATED* _valueChangeListener_
|_public void <methodName>(jakarta.faces.event.ValueChangeEvent);_
|===

Note that for any of the parameters for the
above methods may also be a subclass of what is listed above. For the
above properties that are marked as DEPRECATED, wrapper classes have
been added that wrap a MethodExpression and implement the appropriate
listener interface, allowing the wrapped expression to be added as a
strongly typed listener, using the normal _add*()_ pattern Here is the
list of such wrapper classes:

.MethodExpression wrappers to take the place of DEPRECATED MethodBinding properties
[width="100%",cols="15%,35%,50%",options="header",]
|===
|component listener property
|Wrapper class
|method signature

|_actionListener_
|_jakarta.faces.event.MethodExpressionActionListener_
|_public void <methodName>(jakarta.faces.event.ActionEvent);_

|_validator_
|_jakarta.faces.validator.MethodExpressionValidator_
|_public void <methodName>(jakarta.faces.context.FacesContext,
jakarta.faces.component.UIComponent, java.lang.Object);_

|_valueChangeListener_
|_jakarta.faces.event.MethodExpressionValueChangeListener_
|_public void <methodName>(jakarta.faces.event.ValueChangeEvent);_
|===

The _MethodBinding_ typed _action_ property
of _ActionSource_ is deprecated and has been replaced by the
_MethodExpression_ typed _actionExpression_ property of _ActionSource2_.

[[a2403]]
==== MethodExpression Syntax and Semantics

The exact syntax and semantics of
MethodExpression are the domain of the Jakarta Expression Language. Please see
Section 1.2.1.2 of the Jakarta Expression Language Specification, Version 4.0 or higher.


[[a2406]]
=== The Managed Bean Facility

The use of the managed bean facility as specified in this section is strongly
discouraged. A better and more cohesively integrated solution for
solving the same problem is to use Contexts and Dependency Injection
(CDI). (See <<Preface.adoc#a173,
Other Jakarta Platform Specifications>>).

Perhaps the biggest value-add of bringing Expression Language
concepts to Jakarta Faces happens when the Expression Language is combined with the managed bean
facility. This feature allows the user to configure an entire complex
tree of POJO beans, including how they should be scoped and populated
with initial values, and expose them to Expression Language expressions. Please see
_<<ExpressionLanguageAndManagedBeanFacility.adoc#a2477,Managed Bean Configuration Example>>_.

The Managed Bean Creation facility is
configured by the existence of _<managed-bean>_ elements in one or more
application configuration resources (see <<UsingJSFInWebApplications.adoc#a6195,
Application Configuration Resources>>). Note that a special provision has
been made for application configuration resource files residing within
_META-INF/managed-beans.xml_ entries on the application classpath.
Please see <<UsingJSFInWebApplications.adoc#a6254,Application Configuration
Resource Format>> for the normative spec requirement. Such elements
describe the characteristics of a bean to be created, and properties to
be initialized, with the following nested elements:

* _<managed-bean-name>_ -- The key under which
the created bean can be retrieved; also the key in the scope under which
the created bean will be stored, unless the value of
_<managed-bean-scope>_ is set to _none_.

* _<managed-bean-class>_ -- The fully
qualified class name of the application class used to instantiate a new
instance. This class must conform to JavaBeans design patterns -- in
particular, it must have a public zero-args constructor, and must have
public property setters for any properties referenced with nested
_<managed-property>_ elements -- or it must be a class that implements
_java.util.Map_ or _java.util.List_.

* _<managed-bean-scope>_ -- The scope (
_request_, _view_, _session_, or _application_) under which the
newly instantiated bean will be stored after creation (under the key
specified by the _<managed-bean-name>_ element), or _none_ for a bean
that should be instantiated and returned, but not stored in any scope.
The latter option is useful when dynamically constructing trees of
related objects, as illustrated in the following example. +
The runtime must must allow the value of this element to be an EL
_ValueExpression_. If so, and the expression evaluates to _null_, an
informative error message including the expression string and the name
of the bean must be logged. If the expression evaluates to a _Map_,
that _Map_ is used as the scope into which the bean will be stored. If
storing the bean into the _Map_ causes an _Exception_, the exception is
allowed to flow up to the _ExceptionHandler_. If the _ValueExpression_
does not evaluate to a _Map_, a _FacesException_ must be thrown with a
message that includes the expression string, the _toString()_ of the
value, and the type of the value.

* _<list-entries>_ or _<map-entries>_ -- Used
to configure managed beans that are themselves instances of
_java.util.List_ or _java.util.Map_, respectively. See below for details
on the contents of these elements.

* _<managed-property>_ -- Zero or more
elements used to initialize the properties of the newly instantiated
bean (see below).

After the new managed bean instance is
instantiated, but before it is placed into the specified scope (if any),
each nested _<managed-property>_ element must be processed and a call to
the corresponding property setter must be made to initialize the value
of the corresponding property. If the managed bean has properties not
referenced by _<managed-property>_ elements, the values of such
properties will not be affected by the creation of this managed bean;
they will retain whatever default values are established by the
constructor.

Each _<managed-property>_ element contains
the following elements used to configure the execution of the
corresponding property setter call:

* _<property-name>_ -- The property name of
the property to be configured. The actual property setter method to be
called will be determined as described in the JavaBeans Specification.

* Exactly one of the following sub-elements
that can be used to initialize the property value in a number of
different ways:

** _<map-entries>_ -- A set of key/value pairs
used to initialize the contents of a property of type _java.util.Map_
(see below for more details).

** _<null-value/>_ -- An empty element
indicating that this property must be explicitly initialized to _null_.
This element is not allowed if the underlying property is of a Java
primitive type.

** _<value>_ -- A String value that will have
any leading and trailing spaces stripped, and then be converted
(according to the rules described in the JSP Specification for the
<jsp:setProperty> action) to the corresponding data type of the
property, prior to setting it to this value.

** _<list-entries>_ -- A set of values used to
initialize the contents of a property of type array or _java.util.List_
See below for more information.

As described above, the _<map-entries>_
element is used to initialize the key-value pairs of a property of type
_java.util.Map_. This element may contain the following nested
elements:

- _<key-class>_ -- Optional element specifying
the fully qualified class name for keys in the map to be created. If not
specified, _java.lang.String_ is used.

- _<value-class>_ -- Optional element
specifying the fully qualified class name for values in the map to be
created. If not specified, _java.lang.String_ is used.

- _<map-entry>_ -- Zero or more elements that
define the actual key-value pairs for a single entry in the map. Nested
inside is a _<key>_ element to define the key, and then exactly one of
_<null-value>_, _<value>_ to define the value. These elements have the
same meaning as when nested in a _<managed-property>_ element, except
that they refer to an individual map entry’s value instead of the entire
property value.

As described above, the _<list-entries>_
element is used to initialize a set of values for a property of type
array or _java.util.List_. This element may contain the following
nested elements:

- _<value-class>_ -- Optional element
specifying the fully qualified class name for values in the map to be
created. If not specified, _java.lang.String_ is used.

- Zero or more elements of type _<null-value>_,
_<value>_ to define the individual values to be initialized. These
elements have the same meaning as when nested in a _<managed-property>_
element, except that they refer to an individual list element instead of
the entire property value.

The following general rules apply to the
operation of the Managed Bean Creation facility:

* Properties are assigned in the order that
their _<managed-property>_ elements are listed in the application
configuration resource.

* If a managed bean has writeable properties
that are not mentioned in _<managed-property>_ elements, the values of
those properties are not assigned any values.

* The bean instantiation and population with
properties must be done lazily, when an Expression Language expression causes the bean to
be referenced. For example, this is the case when a _ValueExpression_ or
_MethodExpression_ has its _getValue()_ or _setValue()_ method called.

* Due to the above mentioned laziness
constraint, any error conditions that occur below are only required to
be manifested at runtime. However, it is conceivable that tools may want
to detect these errors earlier; this is perfectly acceptable. The
presense of any of the errors described below, until the end of this
section, must not prevent the application from deploying and being made
available to service requests.

* [P1-start managed bean config error
conditions] It is an error to specify a managed bean class that does not
exist, or that cannot be instantiated with a public, zero-args
constructor.

* It is an error to specify a _<property-name>_
for a property that does not exist, or does not have a public setter
method, on the specified managed bean class.

* {empty}It is an error to specify a _<value>_
element that cannot be converted to the type required by a managed
property, or that, when evaluated, results in a value that cannot be
converted to the type required by a managed property. [P1-end]

* If the type of the property referenced by the
_<managed-property>_ element is a Java enum, the contents of the
_<value>_ element must be a String that yields a valid return from
_java.lang.Enum.valueOf(PROPERTY_CLASS, VALUE)_ where _PROPERTY_CLASS_
is the _java.lang.Class_ for the property and _VALUE_ is the contents of
the _<value>_ element in the application configuration resource. If any
exception is thrown from _Enum.valueOf()_ it is an error.

* [P1-start managed bean scope errors] It is an
error for a managed bean created through this facility to have a
property that points at an object stored in a scope with a (potentially)
shorter life span. Specifically, this means, for an object created with
the specified _<managed-bean-scope>_, then _<value>_ evaluations can
only point at created objects with the specified managed bean scope:

** none -- none

** application -- none, application

** session -- none, application, session

** view -- none, application, session, view

** {empty}request -- none, application, session,
view, request [P1-end]

* If a bean points to a property whose value is
a mixed expression containing literal strings and expressions, the net
scope of the mixed expression is considered to be the scope of the
narrowest sub-expression, excluding expressions in the none scope.

* [P1-start implicit objects in request scope]
Data accessed via an implicit object is also defined to be in a scope.
The following implicit objects are considered to be in request scope:

** _cookie_

** _facesContext_

** _header_

** _headerValues_

** _param_

** _paramValues_

** _request_

** _requestScope_

** {empty} _view_ [P1-end]

* {empty}[P1-start implicit objects in session
scope] The only implicit objects in session scope are _session_ and
_sessionScope_ [P1-end]

* [P1-start implicit objects in application
scope] The following implicit objects are considered to be in
application scope:

** _application_

** _applicationScope_

** {empty} _initParam_ [P1-end]

* {empty}[P1-start cyclic references error] It
is an error to configure cyclic references between managed beans.
[P1-end]

* {empty}[P1-start managed bean names
correctness] Managed bean names must conform to the syntax of a Java
language identifier. [P1-end]

The initialization of bean properties from
_<map-entries>_ and _<list-entries>_ elements must adhere to the
following algorithm, though any confirming implementation may be used.

For _<map-entries>_:

. Call the property getter, if it exists.

. If the getter returns _null_ or doesn't
exist, create a _java.util.HashMap_, otherwise use the returned
_java.util.Map_.

. Add all entries defined by nested
_<map-entry>_ elements in the order they are listed, converting key
values defined by nested _<key>_ elements to the type defined by
_<key-class>_ and entry values defined by nested _<value>_ elements to
the type defined by _<value-class>_. If a value is given as a value
expression, evaluate the reference and store the result, converting to
_<value-class>_ if necessary. If _<key-class>_ and/or _<value-class>_
are not defined, use _java.lang.String_. Add _null_ for each
_<null-value>_ element.

. If a new _java.util.Map_ was created in step
2), set the property by calling the setter method, or log an error if
there is no setter method.

For _<list-entries>_:

. Call the property getter, if it exists.

. If the getter returns _null_ or doesn't
exist, create a _java.util.ArrayList_, otherwise use the returned
_Object_ (an array or a _java.util.List_).

. If a _List_ was returned or created in step
2), add all elements defined by nested _<value>_ elements in the order
they are listed, converting values defined by nested _<value>_ elements
to the type defined by _<value-class>_. If a value is given as a value
expression, evaluate the reference and store the result, converting to
_<value-class>_ if necessary. If a _<value-class>_ is not defined, use
the value as-is (i.e., as a _java.lang.String_). Add null for each
_<null-value>_ element.

. If an array was returned in step 2), create a
_java.util.ArrayList_ and copy all elements from the returned array to
the new _List_, wrapping elements of a primitive type. Add all elements
defined by nested _<value>_ elements as described in step 3).

. If a new _java.util.List_ was created in step
2) and the property is of type _List_, set the property by calling the
setter method, or log an error if there is no setter method.

. If a new _java.util.List_ was created in step
2) and the property is a java array, convert the _List_ into an array of
the property type, and set it by calling the setter method, or log an
error if there is no setter method.

. If a new _java.util.List_ was created in step
4), convert the _List_ to an array of the proper type for the property
and set the property by calling the setter method, or log an error if
there is no setter method.

[[a2477]]
==== Managed Bean Configuration Example

The following <managed-bean> elements might
appear in one or more application configuration resources (see
<<UsingJSFInWebApplications.adoc#a6195,Application Configuration Resources>>) to
configure the behavior of the Managed Bean Creation facility.

Assume that your application includes
_CustomerBean_ with properties _mailingAddress_ and _shippingAddress_ of
type _Address_ (along with additional properties that are not shown),
and _AddressBean_ implementation classes with String properties of type
_street_, _city_, _state_, _country_, and _postalCode_.

[source,xml]
----
<managed-bean>
  <description>
    A customer bean will be created as needed, and stored in request
    scope. Its “mailingAddress” and “streetAddress” properties will
    be initialized by virtue of the fact that the “value” expressions
    will not encounter any object under key “addressBean” in any scope.
  </description>
  <managed-bean-name>customer</managed-bean-name>
  <managed-bean-class>
    com.mycompany.mybeans.CustomerBean
  </managed-bean-class>
  <managed-bean-scope>request</managed-bean-scope>
  <managed-property>
    <property-name>mailingAddress</property-name>
    <value>#{addressBean}</value>
  </managed-property>
  <managed-property>
    <property-name>shippingAddress</property-name>
    <value>#{addressBean}</value>
  </managed-property>
  <managed-property>
    <property-name>customerType</property-name>
    <value>New</value> <!-- Set to literal value -->
  </managed-property>
</managed-bean>
----



[source,xml]
----
<managed-bean>
  <description>
    A new AddressBean will not be added to any scope, because we
    only want to create instances when a CustomerBean creation asks
    for them. Therefore, we set the scope to “none”.
  </description>
  <managed-bean-name>addressBean</managed-bean-name>
  <managed-bean-class>
    com.mycompany.mybeans.AddressBean
  </managed-bean-class>
  <managed-bean-scope>none</managed-bean-scope>
</managed-bean>
----

If a value expression
“_#{customer.mailingAddress.city}_” were to be evaluated by the Jakarta Faces
implementation, and there was no object stored under key “_customer_”
in request, view, session, or application scope, a new _CustomerBean_
instance will be created and stored in request scope, with its
_mailingAddress_ and _shippingAddress_ properties being initialized to
instances of _AddressBean_ as defined by the configuration elements
shown above. Then, the evaluation of the remainder of the expression can
proceed as usual.

Although not used by the Jakarta Faces implementation
at application runtime, it is also convenient to be able to indicate to
Jakarta Faces tools (at design time) that objects of particular types will be
created and made available (at runtime) by some other means. For
example, an application configuration resource could include the
following information to declare that a JDBC data source instance will
have been created, and stored in application scope, as part of the
application’s own startup processing.

[source,xml]
----
<referenced-bean>
  <description>
    A JDBC data source will be initialized and made available in
    some scope (presumably application) for use by the Jakarta Faces based
    application when it is actually run. This information is not
    used by the Jakarta Faces implementation itself; only by tools.
  </description>
  <referenced-bean-name>dataSource</referenced-bean-name>
  <referenced-bean-class>
    javax.sql.DataSource
  </referenced-bean-class>
</referenced-bean>
----

This information can be utilized by the tool
to construct user interfaces based on the properties of the referenced
beans.

[[a2536]]
=== Managed Bean Annotations

Jakarta Faces has several annotations, in
the package _jakarta.faces.bean_, that act as analogs to the managed bean
configuration syntax in the application configuration resources
described earlier in this chapter. Jakarta Faces is a component specification
of Jakarta EE, which also includes a much more powerful and complete set
of annotations, from several other component specifications, most
notably Jakarta Contexts and Dependency Injection (CDI). These annotations are
also usable with Jakarta Faces. The annotations in the package _jakarta.faces.bean_
are deprecated. Therefore, developers are strongly recommended to avoid using those
annotations and instead use the ones from CDI.

==== Jakarta Faces Managed Classes and Jakarta EE Annotations

Jakarta Faces implementations that are running as a
part of Jakarta EE must allow managed bean implementations to
use the annotations specified in section 14.5 of the Jakarta Servlet
Specification to allow the container to inject references to container
managed resources into a managed bean instance before it is made
accessible to the Jakarta Faces application. Only beans declared to be in
_request_, _session_, or _application_ scope are eligible for resource
injection.

In addition to managed beans being injectable
in this manner, the following Jakarta Faces artifacts are also injectable.

[[a2541]]
.Jakarta Faces Artifacts Eligible for Injection

Artifact Type

- jakarta.el.ELResolver

- jakarta.faces.application.ApplicationFactory

- _jakarta.faces.application.NavigationHandler_

- _jakarta.faces.application.ResourceHandler_

- _jakarta.faces.application.StateManager_

- jakarta.faces.component.visit.VisitContextFactory

- jakarta.faces.context.ExceptionHandlerFactory

- jakarta.faces.context.ExternalContextFactory

- jakarta.faces.context.FacesContextFactory

- jakarta.faces.context.PartialViewContextFactory

- _jakarta.faces.event.ActionListener_

- _jakarta.faces.event.SystemEventListener_

- jakarta.faces.lifecycle.ClientWindowFactory

- jakarta.faces.lifecycle.LifecycleFactory

- jakarta.faces.event.PhaseListener

- jakarta.faces.render.RenderKitFactory

- jakarta.faces.view.ViewDeclarationLanguageFactory

- jakarta.faces.view.facelets.FaceletCacheFactory

- jakarta.faces.view.facelets. +
TagHandlerDelegateFactory

{empty}Please consult the Jakarta EE Specification for complete details of this
feature. Here is a summary of the Jakarta EE annotations one may use in a
managed bean or other artifact from the preceding table. [P1-start valid
annotations in a managed bean]

- _@jakarta.inject.Inject_

- @jakarta.inject.Named

- @jakarta.inject.Qualifier

- @jakarta.inject.Scope

- @jakarta.inject.Singleton

- @jakarta.enterprise.context.ApplicationScoped

- @jakarta.enterprise.context.ConversationScoped

- @jakarta.enterprise.context.Dependent

- @jakarta.enterprise.context.RequestScoped

- @jakarta.enterprise.context.SessionScoped

- _@jakarta.annotation.Resource_

- _@jakarta.annotation.Resources_

- _@jakarta.ejb.EJB_

- _@jakarta.ejb.EJBs_

- _@jakarta.xml.ws.WebServiceRef_

- _@jakarta.xml.ws.WebServiceRefs_

- _@jakarta.persistence.PersistenceContext_

- _@jakarta.persistence.PersistenceContexts_

- _@jakarta.persistence.PersistenceUnit_

- _@jakarta.persistence.PersistenceUnits_
[P1-end]

Following is an example of valid usages of
this feature in a managed bean or other artifact in the preceding table.

[source,java]
----
public class User extends Object {
  private @EJB ShoppingCart cart;
  private @Resource Inventory inventory;
  private DataSource customerData;

  @Resource(name=”customerData”)
  private void setCustomerData(DataSource data) {
    customerData = data;
  }

  public String getOrderSummary() {
    // Do something with the injected resources
    // And generate a textual summary of the order
  }
}
----

This example illustrates that the above
annotations can be attached to instance variables or to JavaBeans
setters. The Jakarta Faces implementation running in a Jakarta EE container must
guarantee that the injections are performed before the bean is handed
back to the user. Generally, this is done by performing the injection
immediately after the lazy instantiation of the managed bean.

[[a2601]]
==== Managed Bean Lifecycle Annotations

Jakarta Faces implementations running in a Jakarta EE
compliant container must support attaching the _@PostConstruct_ and
_@PreDestroy_ annotations to aid in awareness of the managed-bean
lifecycle.

Methods on managed beans declared to be in
_none_, _request_, _view_, _session_, or _application_ scope,
annotated with _@PostConstruct_, must be called by the Jakarta Faces
implementation after resource injection is performed (if any) but before
the bean is placed into scope.

{empty}[P1-start rules governing invocation
of @PostConstruct annotated methods]If the method throws an unchecked
exception, the Jakarta Faces implementation must not put the managed-bean into
service, a message must be logged, and further methods on that managed
bean instance must not be called. [P1-end]

Methods on managed beans declared to be in
_request_, _session_, or _application_ scope, annotated with
_@PreDestroy_, must be called by the Jakarta Faces implementation before the bean
is removed from its scope or before the scope itself is destroyed,
whichever comes first. In the case of a managed bean placed in _view_
scope, methods annotated with _@PreDestroy_ must only be called when the
view scope is destroyed. See the javadoc for
_FacesContext.setViewRoot()_. This annotation must be supported in all
cases where the above _@PostConstruct_ annotation is supported.

[P1-start rules governing invocation of
@PreDestroy annotated methods] If the method throws an unchecked
exception, the Jakarta Faces implementation may log it, but the exception must not
otherwise alter the execution.

{empty}Refer to the Jakarta EE specification
section 2.5 and the Jakarta Annotations
specification section 2.5 for more details.[P1-end]


=== How Faces Leverages the Expression Language

This section is non-normative and covers the
major players in the Jakarta Expression Language and how they relate to Jakarta Faces.
The number one goal in this version of the Jakarta Faces
specification is to export the concepts behind the Jakarta Faces EL into the
Jakarta Expression Language, and then rely on those facilities to get the work done.
Readers interested in how to implement the Jakarta Expression Language itself must
consult the Jakarta Expression Language Spec document.

==== ELContext

The ELContext is a handy little “holder”
object that gets passed all around the Jakarta Expression Language API. It has two
purposes.

* To allow technologies that use the Jakarta Expression Language
, such as Jakarta Faces, the Jakarta Faces View Declaration Language, and JSP, 
to store any context information specific to that
technology so it can be leveraged during expression evaluation. For
example the expression “_${view.viewId}_” is specific to Jakarta Faces. It
means, “find the _UIViewRoot_ instance for the current view, and return
its _viewId_”. The Jakarta Expression Language doesn’t know about the “view” implicit
object or what a UIViewRoot is, but Jakarta Faces does. The Jakarta Expression Language
has plugin points that will get called to resolve “view”, but to do
so, Jakarta Faces needs access to the _FacesContext_ from within the
callstack of Expression Language evaluation. Therefore, the _ELContext_ comes to the
rescue, having been populated with the _FacesContext_ earlier in the
request processing lifecycle.

* To allow the pluggable resolver to tell the
Jakarta Expression Language that it did, in fact, resolve a property and that further
resolvers must not be consulted. This is done by setting the
“_propertyResolved_” property to _true_.

The complete specification for ELResolver may
be found in Chapter 2 of the Jakarta Expression Language Specification, Version
4.0.

===== Lifetime, Ownership and Cardinality

An ELContext instance is created the first
time _getELContext()_ is called on the _FacesContext_ for this request.
Please see _<<Per-RequestStateInformation.adoc#a3099,ELContext>>_ for details. Its
lifetime ends the same time the __FacesContext__’s lifetime ends. The
_FacesContext_ maintains the owning reference to the _ELContext_. There
is at most one _ELContext_ per _FacesContext_.

===== Properties

[width="100%",cols="20%,10%,20%,50%",options="header",]
|===
|Name |Access
|Type |Description
| _ELResolver_ |RO
| _jakarta.el.ELResolver_
|Return the ELResolver instance described in
_<<ExpressionLanguageAndManagedBeanFacility.adoc#a2667,Faces ELResolver for JSP Pages>>_

| _propertyResolved_
|RW |boolean
|Set by an ELResolver implementation if it
successfully resolved a property. See _<<ExpressionLanguageAndManagedBeanFacility.adoc#a2634,
ELResolver>>_ for how this property is used.
|===

===== Methods

Here is a subset of the methods that are relevant to Jakarta Faces.

[source,java]
----
public Object getContext(Class key);
void putContext(Class key, Object contextInstance);
...
----

As mentioned in
_<<Per-RequestStateInformation.adoc#a3099,ELContext>>_, the _putContext()_ method
is called, passing the current _FacesContext_ instance the first time
the system asks the _FacesContext_ for its _ELContext_. The
_getContext()_ method will be called by any _ELResolver_ instances that
need to access the _FacesContext_ to perform their resolution.

===== Events

The creation of an ELContext instance
precipitates the emission of an _ELContextEvent_ from the _FacesContext_
that created it. Please see _<<Per-RequestStateInformation.adoc#a3099,ELContext>>_
for details.

[[a2634]]
==== ELResolver

Faces 1.1 used the _VariableResolver_ and
_PropertyResolver_ classes as the workhorses of expression evaluation.
The Unified API has the _ELResolver_ instead. The ELResolver concept is
the heart of the Jakarta Expression Language. When an expression is evaluated, the
ELResolver is responsible for resolving each segment in the expression.
For example, in rendering the component behind the tag “_<h:outputText
value=”#{user.address.street}” />”_ the ELResolver is called three
times. Once to resolve “user”, again to resolve the “address” property
of user, and finally, to resolve the “street” property of “address”. The
complete specification for ELResolver may be found in Chapter 2 of the
Jakarta Expression Language Specification, Version 4.0 or higher.

[N/T-start two ELResolver impls] As described
in more detail in _<<ExpressionLanguageAndManagedBeanFacility.adoc#a2667,Faces ELResolver for
JSP Pages>>_, Faces must provide two implementations of _ELResolver_.
[P1-end]Which of these two implementations is actually used to resolve
an expression depends on where the expresison is evaluated. If the
expression is evaluated in a markup page, the ELResolver for markup
pages is used. If the expression is evaluated in java VM hosted code
from Faces, another ELResolver is used that is tailored for use inside
of Faces java VM hosted code. During the course of evaluation of an
expression, a variety of sources must be considered to help resolve each
segment of the expression. These sources are linked in a chain-like
fashion. Each link in the chain has the opportunity to resolve the
current segment. If it does so, it must set the “_propertyResolved_”
property on the _ELContext_, to _true_. If not, it must not modify the
value of the “_propertyResolved_” property. If the
“_propertyResolved_” property is not set to _true_ the return value from
the _ELResolver_ method is ignored by the system.

===== Lifetime, Ownership, and Cardinality

ELResolver instances have application
lifetime and scope. The JSP container maintains one top level ELResolver
(into which a Faces specific ELResolver is added) accessible from
_JspContext.getELContext().getELResolver()_. This ELResolver instance is
also used from the Jakarta Faces VDL, even though Jakarta Faces VDL pages do not themselves
use JSP. Faces maintains one _ELResolver_ (separate from the one handed
to the JSP container) accessible from
_FacesContext.getELContext().getELResolver()_ and
_Application.getELResolver()_.

===== Properties

ELResolver has no proper JavaBeans properties

===== Methods

Here is a subset of the methods that are
relevant to Faces.

[source,java]
----
public Object getValue(ELContext context, Object base, Object property);
void setValue(ELContext context,
    Object base, Object property, Object value);
...
----

_getValue()_ looks at the argument _base_
and tries to return the value of the property named by the argument
_property_. For example, if base is a JavaBean, _property_ would be the
name of the JavaBeans property, and the resolver would end up calling
the _getter_ for that property.

_setValue()_ looks at the argument _base_
and tries to set the argument _value_ into the property named by the
argument _property_. For example, if base is a JavaBean, _property_
would be the name of the JavaBeans property, and the resolver would end
up calling the _setter_ for that property.

There are other methods, such as
_isReadOnly()_ that are beyond the scope of this document, but described
completely in the Jakarta Expression Language Specification.

===== Events

_ELResolver_ precipitates no events.

[[a2651]]
==== ExpressionFactory

Pre-Jakarta Faces JSF 1.1 (under the JCP) used the Application class as a
factory for _ValueBinding_ and _MethodBinding_ instances. The Jakarta Expression Language
has the _ExpressionFactory_ class instead. It is a factory for
_ValueExpression_ and _MethodExpression_ instances.

===== Lifetime, Ownership, and Cardinality

_ExpressionFactory_ instances are
application scoped. The _Application_ object maintains the
_ExpressionFactory_ instance used by Faces (See
_<<ApplicationIntegration.adoc#a3459,Acquiring ExpressionFactory Instance>>)_.
The _JspApplicationContext_ object maintains the _ExpressionFactory_
used by the JSP container (and therefore by the Jakarta Faces VDL). It is
permissible for both of these access methods to yield the same java
object instance.

===== Properties

_ExpressionFactory_ has no properties.

===== Methods

[source,java]
----
public MethodExpression createMethodExpression(ELContext context,
    String expression, FunctionMapper fnMapper, Class[] paramTypes);
public ValueExpression createValueExpression(ELContext context,
    String expression, Class expectedType, FunctionMapper fnMapper);
----

These methods take the human readable
expression string, such as _”#{user.address.street}”_ and return an
object oriented representation of the expression. Which method one calls
depends on what kind of expression you need. The Faces _Application_
class has convenience methods specific to Faces needs for these
concepts, please see <<ApplicationIntegration.adoc#a3463,Programmatically
Evaluating Expressions>> .

===== Events

_ExpressionFactory_ precipitates no events.


[[a2664]]
=== ELResolver Instances Provided by Faces

This section provides details on what an
implementation of the Jakarta Server Faces specification must do to support
the Jakarta Expression Language for usage in a Jakarta Faces application.

_<<ExpressionLanguageAndManagedBeanFacility.adoc#a2634,
ELResolver>>_ mentions that a Faces implementation must provide two
implementations of ELResolver. One ELResolver, let’s call it the _Faces
ELResolver For Markup Pages_, is plugged in to the top level resolver
chain returned from _JspContext.getELContext().getELResolver()_. This
top level resolver chain is used by the view declaration language
container (JSP or Jakarta Faces View Declaration Language), and possibly by tag
handlers, to resolve expressions. The other _ELResolver_, let’s call it
the _ELResolver for Facelets and Programmatic Access_, is used by
Facelets markup pages, and is returned from
_FacesContext.getELContext().getELResolver()_ and
_Application.getELResolver()_, and is used to resolve expressions that
appear programmatically. See the javadocs for _jakarta.el.ELResolver_ for
the specification and method semantics for each method in _ELResolver_.
The remainder of this section lists the implementation requirements for
these two resolvers.

[[a2667]]
==== Faces ELResolver for JSP Pages

As mentioned in
_<<ExpressionLanguageAndManagedBeanFacility.adoc#a2634,ELResolver>>_, during the course of
evaluation of an expression, a variety of sources must be considered to
help resolve each segment of the expression. These sources are linked in
a chain-like fashion. Each link in the chain has the opportunity to
resolve the current segment. The Jakarta Expression Language provides a container class
to support this multi-source variable resolution:
_jakarta.el.CompositeELResolver_. The implementation for the _Faces
ELResolver for JSP Pages_ is described as a set of _ELResolvers_ inside
of a _CompositeELResolver_ instance, but any implementation strategy is
permissible as long as the semantics are preserved.

{empty}This diagram shows the set of
_ELResolver_ instances that must be added to the _Faces ELResolver for
JSP Pages_. This instance must be handed to the JSP container via a
call to
_JspFactory.getDefaultFactory().getJspApplicationContext().addELResolver()_
at application startup time. Even though we are making a JSP API call to
install this _ELResolver_, we do not require using JSP to develop Jakarta Faces
applications. It also shows the order in which they must be added.
[P2-start there are 18 methods in the below tables, each can
corresponding to a method on a particular ELResolver. With clever
testing, it is possible to write assertions for these. Testing the
legacy VariableResolver and PropertyResolvers is not included in this 18
methods number. These classes may be tested simply by noting that the
methods do indeed get called on a user-provided VariableResolver or
PropertyResolver.] [P1-end]

[[a2670]]
.Faces ELResolver for JSP Pages



image:SF-26.png[image]

The semantics of each ELResolver are given
below, either in tables that describe what must be done to implement
each particular method on _ELResolver_, or in prose when such a table
is inappropriate.

[[a2673]]
===== Faces Implicit Object ELResolver For JSP

This resolver relies on the presence of
another, JSP specific, implicit object ELResolver in the chain by only
resolving the “facesContext” and “view” implicit objects.

.Faces ImplicitObjectELResolver for JSP

[width="100%",cols="25%,75%",options="header",]
|===
|ELResolver method
|implementation requirements
| _getValue_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

<<ExpressionLanguageAndManagedBeanFacility.adoc#a2832,See
ImplicitObjectELResolver for Programmatic Access>> If base is null and
property is a String equal to
“facesContext”, call
setPropertyResolved(true) on
the argument ELContext and return the
FacesContext
for this request.

If base is null and property is a String
equal to
“view”, call setPropertyResolved(true) on the
argument ELContext and return the UIViewRoot
for
this request by calling
facesContext.getUIViewRoot().

{empty}This ELResolver must also support the
implicit object “resource” as specified in
<<ExpressionLanguageAndManagedBeanFacility.adoc#a2830,Implicit Object ELResolver for Facelets
and Programmatic Access>>

| _getType_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

If base is null and property is a String
equal to “facesContext” or “view”, call setPropertyResolved(true) and
return null;

{empty}Otherwise, just return null;This
ELResolver must also support the implicit object “resuorce” as specified
in <<ExpressionLanguageAndManagedBeanFacility.adoc#a2830,Implicit Object ELResolver for
Facelets and Programmatic Access>>

| _setValue_ a|
If base is null and property is null, throw
PropertyNotFoundException.

{empty}If base is null and property is a
String equal to “facesContext” or “view”, _throw
jakarta.el.PropertyNotWriteable_, since “view” and “facesContext” are
read-only. This ELResolver must also support the implicit object
“resuorce” as specified in <<ExpressionLanguageAndManagedBeanFacility.adoc#a2830,Implicit
Object ELResolver for Facelets and Programmatic Access>>

| _isReadOnly_ a|
If base is non-null, return false.

If base is null and property is null, throw
PropertyNotFoundException.

If base is null and property is a String
equal to “facesContext” or “view”, call _setPropertyResolved(true)_ on
the argument _ELContext_ and return _true_.

{empty}Otherwise return false;This ELResolver
must also support the implicit object “resuorce” as specified in
<<ExpressionLanguageAndManagedBeanFacility.adoc#a2830,Implicit Object ELResolver for Facelets
and Programmatic Access>>

| _getFeatureDescriptors_ a|
If base is non-null, return null.

If base is null, return an Iterator
containing three java.beans.FeatureDescriptor instances, one for the
“view” property, one for the “facesContext” property and one for the
“resource” property. It is required that all of the FeatureDescriptor
instances in the Iterator set Boolean.TRUE as the value of the
ELResolver.RESOLVABLE_AT_DESIGN_TIME attribute. The name and displayName
of the FeatureDescriptor must be “view”, “facesContext”, “ or “resource”
as appropriate. FacesContext.class, UIViewRoot.class, or
ResourceHandler.class must be stored as the value of the ELResolver.TYPE
attribute, as approriate. The shortDescription must be a suitable
description depending on the implementation. The expert and hidden
properties must be false. The preferred property must be true.

| _getCommonPropertyType_ a|
If base is non-null, return null.

If base is null and return String.class.

|===


[[a2711]]
===== ManagedBean ELResolver

This is the means by which the managed bean
creation facility described in _<<ExpressionLanguageAndManagedBeanFacility.adoc#a2406,The
Managed Bean Facility>>_ is called into play during Expression Language resolution.

.ManagedBeanELResolver

[width="100%",cols="25%,75%",options="header",]
|===
|ELResorver method
|implementation requirements
| _getValue_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

If property matches the name of an entry in
the request, session, or application scopes, in that order, return null.

If base is null, and property matches one of
the managed-bean-name declarations in the application configuration
resources, instantiate the bean, populate it with properties as
described in _<<ExpressionLanguageAndManagedBeanFacility.adoc#a2406,The Managed Bean
Facility>>_, store it in the scope specified by the managed-bean-scope
declaration for this this managed-bean, call setPropertyResolved(true)
on the argument ELContext, and return the freshly instantiated
managed-bean.

Otherwise, return null.

| _getType_ a|
If base is null and property is null, throw
PropertyNotFoundException.

Otherwise return null;

| _setValue_ a|
If base is null and property is null, throw
PropertyNotFoundException.

Otherwise, if base is null, and property
matches one of the managed-bean-name declarations in the application
configuration resources, and a managed bean with that managed-bean-name
does not yet exist in the specified scope, instantiate the bean,
populate it with properties as described in
_<<ExpressionLanguageAndManagedBeanFacility.adoc#a2406,The Managed Bean Facility>>_, store it
in the scope specified by the managed-bean-scope declaration for this
this managed-bean and return. If the managed bean does exist, take no
action and return. In either case (the bean exists or does not exist),
the actual setting will happen by virtue of the BeanELResolver.

Otherwise take no action and return.

| _isReadOnly_ a|
If base is non-null, return false.

If base is null and property is null, throw
PropertyNotFoundException.

If base is null return false. We never set
the propertyResloved property in this method because the set
responsibility is taken care of by the ScopedAttributeELResolver.

| _getFeatureDescriptors_ a|
If base is non-null, return null.

If base is null, return an Iterator
containing java.beans.FeatureDescriptor instances for each managed-bean
in the application-configuration resources. It is required that all of
the FeatureDescriptor instances in the Iterator set Boolean.TRUE as the
value of the ELResolver.RESOLVABLE_AT_DESIGN_TIME attribute. The name
and displayName of the FeatureDescriptor must be the managed-bean-name.
The actual java Class instance for the managed-bean-class must be stored
as the value of the ELResolver.TYPE attribute. The shortDescription of
the FeatureDescriptor must be the description of the managaged-bean
element, if present, null otherwise. The expert and hidden properties
must be false. The preferred property must be true.

| _getCommonPropertyType_ a|
If base is non-null, return null.

If base is null, return Object.class.

|===

===== Resource ELResolver

Please see <<ExpressionLanguageAndManagedBeanFacility.adoc#a2940,
Resource ELResolver>> for the specification of this ELResolver.

[[a2741]]
===== ResourceBundle ELResolver for JSP Pages

This is the means by which resource bundles
defined in the application configuration resources are called into play
during Expression Language resolution.

.ResourceBundleELResolver

[width="100%",cols="25%,75%",options="header",]
|===
|ELResorver method
|implementation requirements
| _getValue_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

If base is null and property is a String
equal to the value of the <var> element of one of the
<resource-bundle>'s in the application configuration resources, use the
Locale of the current UIViewRoot and the base-name of the
resource-bundle to load the ResourceBundle. Call
setPropertyResolved(true). Return the ResourceBundle. Otherwise, return
null.



| _getType_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

If base is null and property is a String
equal to the value of the <var> element of one of the
<resource-bundle>'s in the application configuration resources, call
setPropertyResolved(true) and return ResourceBundle.class.



| _setValue_ a|
If base is null and property is null, throw
PropertyNotFoundException.

If base is null and property is a String
equal to the value of the <var> element of one of the
<resource-bundle>'s in the application configuration resources throw
jakarta.el.PropertyNotWriteable, since ResourceBundles are read-only.



| _isReadOnly_ a|
If base is non-null, return null.

If base is
false and property is null, throw PropertyNotFoundException.

If base is
null and property is a String equal to the value of the <var> element of
one of the <resource-bundle>'s in the application configuration
resources, call setPropertyResolved(true) on the argument ELContext and
return true.

Otherwise return false;



| _getFeatureDescriptors_ a|
If base is non-null, return null.

If base is null, return an Iterator
containing java.beans.FeatureDescriptor instances, one for each
<resource-bundle> in the <application> element. It is required that all
of these FeatureDescriptor instances set Boolean.TRUE as the value of
the ELResolver.RESOLVABLE_AT_DESIGN_TIME attribute. The name of the
FeatureDescriptor must be the var element of the <resource-bundle>. The
displayName of the FeatureDescriptor must be the display-name of the
<resource-bundle>. ResourceBundle.class must be stored as the value of
the ELResolver.TYPE attribute. The shortDescription must be a suitable
description depending on the implementation. The expert and hidden
properties must be false. The preferred property must be true.



| _getCommonPropertyType_ a|
If base is non-null, return null.

If base is null, return string.Class.



|===


[[a2771]]
===== ELResolvers in the application configuration resources

The _<el-resolver>_ element in the
application configuration resources will contain the fully qualified
classname to a class with a public no-arg constructor that implements
_jakarta.el.ELResolver_. These are added to the _Faces ELResolver for JSP
Pages_ and the Faces ELResolver for Facelets and Programmatic Access in
the order in which they occur in the application configuration
resources.

[[a2773]]
===== VariableResolver Chain Wrapper

This is the means by which _VariableResolver_
instances that have been specified in _<variable-resolver>_ elements
inside the application configuration resources are allowed to affect the
EL resolution process. If there are one or more _<variable-resolver>_
elements in the application configuration resources, an instance of
ELResolver with the following semantics must be created and added to the
_Faces ELResolver for JSP Pages_ as indicated in the
_<<ExpressionLanguageAndManagedBeanFacility.adoc#a2670,Faces ELResolver for JSP Pages>>_.

By virtue of the decorator pattern described
in _<<UsingJSFInWebApplications.adoc#a6336,Delegating Implementation Support>>_
, the default _VariableResolver_ will be at the end of the
_VariableResolver_ chain (See _<<ExpressionLanguageAndManagedBeanFacility.adoc#a3020,
VariableResolver and the Default VariableResolver>>_), if each custom
_VariableResolver_ chose to honor the full decorator pattern. If the
custom _VariableResolver_ chose not to honor the decorator pattern, the
user is stating that they want to take over complete control of the
variable resolution system. Note that the head of the _VariableResolver_
chain is no longer accessible by calling
_Application.getVariableResolver()_ (Please see
_<<ApplicationIntegration.adoc#a4171,VariableResolver Property>>_ for what it
returns). The head of the _VariableResolver_ chain is kept in an
implementation specific manner.

The semantics of the ELResolver that
functions as the VariableResolver chain wrapper are described in the
following table.

.ELResolver that is the VariableResolver Chain Wrapper

[width="100%",cols="25%,75%",options="header",]
|===
|ELResorver method
|implementation requirements
| _getValue_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

Otherwise, call setPropertyResolved(true) on
the argument ELContext.

Get the ELContext from the FacesContext.

Get the head of the VariableResolver chain
and call resolveVariable(facesContext, property) and return the result.

Catch any exceptions that may be thrown by
resolveVariable(), call setPropertyResolved(false) on the argument
ELContext, and rethrow the exception wrapped in an jakarta.el.ELException.

| _getType_ a|
If base is null and property is null, throw
PropertyNotFoundException.

return null;

| _setValue_ |If
base is null and property is null throw PropertyNotFoundException.

| _isReadOnly_ a|
If base is null and property is null throw
PropertyNotFoundException.

return false;

| _getFeatureDescriptors_
|return null;

| _getCommonPropertyType_
|If base is null, we return String.class.

If base is non-null, return null;
|===

[[a2798]]
===== PropertyResolver Chain Wrapper

This is the means by which _propertyResolver_
instances that have been specified in _<property-resolver>_ elements
inside the application configuration resources are allowed to affect the
EL resolution process. If there are one or more _<property-resolver>_
elements in the application configuration resources, an instance of
_ELResolver_ with the following semantics must be created and added to
the _Faces ELResolver for JSP Pages_ as indicated in the
_<<ExpressionLanguageAndManagedBeanFacility.adoc#a2670,Faces ELResolver for JSP Pages>>_.

By virtue of the decorator pattern described
in _<<UsingJSFInWebApplications.adoc#a6336,Delegating Implementation Support>>_,
the default _propertyResolver_ will be at the end of the
_propertyResolver_ chain (See, _<<ExpressionLanguageAndManagedBeanFacility.adoc#a3025,
PropertyResolver and the Default PropertyResolver>>_), if each custom
_propertyResolver_ chose to honor the full decorator pattern. If the
custom _propertyResolver_ chose not to honor the decorator pattern, then
the user is stating that they want to take over complete control of the
_propertyResolution_ system. Note that the head of the
_propertyResolver_ chain is no longer accessible by calling
_Application.getPropertyResolver()_ (Please see
_<<ApplicationIntegration.adoc#a4163,PropertyResolver Property>>_ for what it
returns). The head of the property resolver chain is kept in an
implementation specific manner.

The semantics of the ELResolver that
functions as the property resolver chain wrapper are described in the
following table.

.ELResolver that is the PropertyResolver Chain Wrapper

[width="100%",cols="25%,75%",options="header",]
|===
|ELResorver method
|implementation requirements
a|
_getValue_,

_getType_,

_isReadOnly_,

_setValue_

a|
If base or property are null, return null (or
false if the method returns boolean).

Call setPropertyResolved(true) on the
argument ELContext.

Get the ELContext from the FacesContext.

Get the head of the propertyResolver chain.

If base is a List or java language array,
coerce the property to an int and call the corresponding method on the
head of the property resolver chain that takes an int for property,
returning the result (except in the case of setValue()).

Otherwise, call the corresponding method on
the head of the property resolver chain that takes an Object for
property, returning the result (except in the case of setValue()).

If an Exception is thrown by calling the
above methods on the PropertyResolver chain, catch it, call
setPropertyResolved(false) on the argument ELContext, and rethrow the
Exception wrapped (snuggly) in a jakarta.el.ELException.

| _getFeatureDescriptors_
|return null;

| _getCommonPropertyType_
|If base is null, return null.

If base is non-null, return Object.class.
|===

[[a2820]]
===== ELResolvers from Application.addELResolver()

Any such resolvers are considered at this
point in the _Faces ELResolver for JSP Pages_ in the order in which they
were added.

[[a2822]]
==== ELResolver for Facelets and Programmatic Access

This section documents the requirements for
the second _ELResolver_ mentioned in _<<ExpressionLanguageAndManagedBeanFacility.adoc#a2664,
ELResolver Instances Provided by Faces>>_, the one that is used for
Facelets and for programmatic expression evaluation from Faces java
code.

The implementation for the _ELResolver for
Programmatic Access_ is described as a set of _ELResolvers_ inside of a
_CompositeELResolver_ instance, but any implementation strategy is
permissible as long as the semantics are preserved. .

{empty}This diagram shows the set of
_ELResolver_ instances that must be added to the _ELResolver for
Programmatic Access_. This instance must be returned from
_Application.getELResolver()_ and
_FacesContext.getELContext().getELResolver()_. It also shows the
order in which they must be added. [P1-state there are 12 methods in the
below tables that can be tested for assertion. The remainder of the
section is covered by the tests in 5.6.1][P1-end]


[[a2827]]
._ELResolver_ for Facelets and Programmatic Access



image:SF-27.png[image]

The semantics of each _ELResolver_ are given
below, either in tables that describe what must be done to implement
each particular method on _ELResolver_, in prose when such a table is
inappropriate, or as a reference to another section where the semantics
are exactly the same.

[[a2830]]
===== Implicit Object ELResolver for Facelets and Programmatic Access

This resolver differs from the one in the
<<ExpressionLanguageAndManagedBeanFacility.adoc#a2673,Faces Implicit Object ELResolver For
JSP>> in that it must resolve all of the implicit objects, not just
_facesContext_ and _view_

[[a2832]]
.ImplicitObjectELResolver for Programmatic Access

[width="100%",cols="25%,75%a",options="header",]
|===
|ELResolver method
|implementation requirements
| _getValue_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

If base is null and property is a String
equal to _implicitObject_, call setPropertyResolved(true) on the
argument ELContext and return _result_, where _implicitObject_ and
_result_ are as follows:

[cols="30%,70%",options="header",]
!===
!_implicitObject_ !_result_
!application !externalContext.getContext()
!applicationScope !externalContext.getApplicationMap()
!cookie !externalContext.getRequestCookieMap()
!facesContext !the FacesContext for this request

!{empty}component
!the top of the stack of UIComponent instances, as pushed via calls to
UIComponent.pushComponentToEL().
See <<UserInterfaceComponentModel.adoc#a1059,Lifecycle Management Methods>>

!flowScope
!facesContext.getApplication().getFlowHandler().getCurrentFlowScope()

!cc !the current composite component
relative to the declaring page in which the expression appears.

!flash !externalContext.getFlash()
!header !externalContext.getRequestHeaderMap()
!headerValues !externalContext.getRequestHeaderValuesMap()
!initParam !externalContext.getInitParameterMap()
!param !externalContext.getRequestParameterMap()
!paramValues !externalContext.getRequestParameterValuesMap()
!request !externalContext.getRequest()
!requestScope !externalContext.getRequestMap()
!resource !facesContext.getApplication().getResourceHandler()
!session !externalContext.getSession()
!sessionScope !externalContext.getSessionMap()
!view !facesContext.getViewRoot()
!viewScope !facesContext.getViewRoot().getViewMap()
!resource !facesContext.getApplication().getResourceHandler()
!===

If base is null, and property doesn’t match
one of the above _implicitObjects_, return null.

| _getType_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

If base is null and property is a String
equal to “application”, “component”, “cc”, “cookie”, “facesContext”,
“header”, “headerValues”, “initParam”, “param”, “paramValues”,
“request”, “resource”, “session”, or “view”, _call
setPropertyResolved(true) on the argument ELContext and return null to
indicate that no types are accepted to setValue() for these attributes_.

If base is null and property is a String
equal to “requestScope”, “sessionScope”, or “applicationScope”, _call
setPropertyResolved(true) on the argument ELContext and return null_.

Otherwise, null;

| _setValue_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

If base is null and property is a String
equal to
“applicationScope”, “requestScope”,
“sessionScope”, “application”, “component”, “cc”, “cookie”,
“facesContext”, “header”, “headerValues”, “initParam”, “param”,
“paramValues”, “request”, “resource”, “session”, or “view”, _throw
jakarta.el.PropertyNotWriteableException_, since these implicit objects are
read-only.

Otherwise return null.

| _isReadOnly_ a|
If base is non-null, return (or false if the
method returns boolean).

If base is null and property is null, throw
PropertyNotFoundException.

If base is null and property is a String
equal to “applicationScope”, “component”, “cc”, “requestScope”,
“sessionScope”, “application”, “cookie”, “facesContext”, “header”,
“headerValues”, “initParam”, “param”, “paramValues”, “request”,
“resource”, “session”, or “view”, _call setPropertyResolved(true) on the
argument ELContext and return true_.

Otherwise return null.

| _getFeatureDescriptors_ a|
If base is non-null, return null.

If base is null, return an Iterator
containing 17 java.beans.FeatureDescriptor instances, one for eath of
the following properties: application, component, cc, cookie,
facesContext, header, headerValues, initParam, param, paramValues,
request, resource, session, view, applicationScope, sessionScope, and
requestScope. It is required that all of these FeatureDescriptor
instances set Boolean.TRUE as the value of the
ELResolver.RESOLVABLE_AT_DESIGN_TIME attribute. For the name and short
of FeatureDescriptor, return the implicit object name. The appropriate
Class must be stored as the value of the ELResolver.TYPE attribute as
follows:

[cols="30%,70%",options="header",]
!===
!implicitObject !ELResolver.TYPE value
!application !Object.class
!applicationScope !Map.class
!component !UIComponent.class
!cc !UIComponent.class
!cookie !Map.class
!facesContext !FacesContext.class
!header !Map.class
!headerValues !Map.class
!initParam !Map.class
!param !Map.class
!paramValues !Map.class
!request !Object.class
!resource !Object.class
!requestScope !Map.class
!session !Object.class
!sessionScope !Map.class
!view !UIViewRoot.class
!===

The shortDescription must be a suitable
description depending on the implementation. The expert and hidden
properties must be false. The preferred property must be true.

| _getCommonPropertyType_ a|
If base is non-null, return null.

If base is null and return String.class

|===

[[a2908]]
===== Composite Component Attributes ELResolver

This ELResolver makes it so expressions that
refer to the attributes of a composite component get correctly
evaluated. For example, the expression _#{cc.attrs.usernameLabel}_
says, “find the current composite component, call its _getAttributes()_
method, within the returned _Map_ look up the value under the key
“usernameLable”. If the value is a _ValueExpression_, call _getValue()_
on it and the result is returned as the evaluation of the expression.
Otherwise, if the value is _not_ a _ValueExpression_ the value itself is
returned as the evaluation of the expression.”

.Composite Component Attributes ELResolver

[width="100%",cols="25%,75%",options="header",]
|===
|ELResolver method
|implementation requirements
| _getValue_ a|
If base is non-null, is an instance of
UIComponent, is a composite component, and property is non-null and is
equal to the string “attrs”, return a Map implementation with the
following characteristics.

Wrap the attributes map of the composite
component and delegate all calls to the composite component attributes
map with the following exceptions:

get(), put(), and containsKey() are required
to be supported.

get(): if the result of calling get() on the
component attributes map is null, and a default value was declared in
the composite component metadata, the value will be a ValueExpression.
Evaluate it and return it. Otherwise, simply return the value from the
component attributes map.

put(): Call getValueExpression() on the
component. If this returns non-null, call setValue() on it, passing the
value argument as the last argument. Otherwise, simply call through to
put on the component attributes map.

containsKey(): If the attributes map contains
the key, return true. Otherwise, if a default value has been declared
for the attribute, return true. Otherwise, return false.

The Map implementation must also implement
the interface

jakarta.faces.el.CompositeComponentExpressionHolder.

Otherwise, take no action.

| _getType_ |If
the base argument to getType() is not an instance of the composite
component attributes map or the property argument to getType() is not an
instance of java.lang.String, return null. Otherwise, check the top
level component's ValueExpression collection for an expression under the
name given by the property argument to getType(). If the expression
exists, call getType() on the expression. If the property argument to
getType() is not empty, search the composite component's metadata for a
declared type on a <composite:attribute> whose name matches the property
argument to getType(). If the expression and the metadata both yield
results, the metadata takes precedence ONLY if it provides a narrower
result than does the expression, i.e. expression type is assignable from
metadata type. If the metadata result does take precedence, call
ELContext.setPropertyResolved(true). Otherwise, return whichever result
was available, or null.

| _setValue_ |Take
no action.

| _isReadOnly_
|Take no action and return true.

| _getFeatureDescriptors_
|Take no action.

| _getCommonPropertyType_
|Return String.class
|===



===== The CompositeELResolver

As indicated in
_<<ExpressionLanguageAndManagedBeanFacility.adoc#a2827,ELResolver for Facelets and
Programmatic Access>>_, following the ImplicitObjectELResolver, the
semantics obtained by adding a _CompositeELResolver_ must be inserted
here. This _ELResolver_ contains the following _ELResolvers_, described
in the referenced sections.

. _<<ExpressionLanguageAndManagedBeanFacility.adoc#a2771,ELResolvers
in the application configuration resources>>_

. _<<ExpressionLanguageAndManagedBeanFacility.adoc#a2773,
VariableResolver Chain Wrapper>>_

. _<<ExpressionLanguageAndManagedBeanFacility.adoc#a2798,
PropertyResolver Chain Wrapper>>_

. _<<ExpressionLanguageAndManagedBeanFacility.adoc#a2820,ELResolvers
from Application.addELResolver()>>_

===== ManagedBean ELResolver

This resolver has the same semantics as the
one in _<<ExpressionLanguageAndManagedBeanFacility.adoc#a2711,ManagedBean ELResolver>>_.

[[a2940]]
===== Resource ELResolver

This resolver is a means by which Resource
instances are encoded into a faces request such that a subsequent faces
resource request from the browser can be satisfied using the
ResourceHandler as described in _<<RequestProcessingLifecycle.adoc#a746,
Resource Handling>>_.

.ResourceELResolver

[width="100%",cols="25%,75%",options="header",]
|===
|ELResorver method
|implementation requirements
| _getValue_ a|
If base and property are not null, and base
is an instance of ResourceHandler (as will be the case with an
expression such as #\{resource[‘ajax.js’]}, perform the following.
(Note: This is possible due to the ImplicitObjectELResolver returning
the ResourceHandler, see <<ExpressionLanguageAndManagedBeanFacility.adoc#a2830,Implicit Object
ELResolver for Facelets and Programmatic Access>>)

* If _property_ does not contain a colon
character ‘:’, treat _property_ as the _resourceName_ and pass
_property_ to _ResourceHandler.createResource(resourceName)_.

* If _property_ contains a single colon
character ‘:’, treat the content before the ‘:’ as the _libraryName_ and
the content after the ‘:’ as the _resourceName_ and pass both to
_ResourceHandler.createResource(resourceName, libraryName)_. If the
value of _libraryName_ is the literal string “this” (without the
quotes), discover the library name of the current resource (or the
contract name of the current resource, the two are mutually exclusive)
and replace “this” with that library name (or contract name) before
calling _ResourceHandler.createResource()_. In the case of resource
library contracts, _libraryName_ will actually be the contract name.

* If _property_ contains more than one colon
character ‘:’, throw a localized _ELException_, including _property_.

If one of the above steps results in the
creation of a non-null Resource instance, call
ELContext.setPropertyResolved(true). Call the getRequestPath() method on
the Resource instance, pass the result through
ExternalContext.encodeResourceUrl() and return the result.

| _getType_
|Return null. This resolver only performs
lookups.

| _setValue_ |Take
no action.

| _isReadOnly_
|Return false in all cases.

| _getFeatureDescriptors_
|Return null.

| _getCommonPropertyType_ a|
If base is non-null, return null.

If base is null, return Object.class.

|===


[[a2962]]
===== el.ResourceBundleELResolver

This entry in the chain must have the
semantics the same as the class _jakarta.el.ResourceBundleELResolver_.
The default implementation just includes an instance of this resolver in
the chain.

[[a2964]]
===== ResourceBundle ELResolver for Programmatic Access

This resolver has the same semantics as the
one in <<ExpressionLanguageAndManagedBeanFacility.adoc#a2741,ResourceBundle ELResolver for JSP
Pages>>.

[[a2966]]
===== Stream, StaticField, Map, List, Array, and Bean ELResolvers

These ELResolver instances are provided by
the Jakarta Expression Language API and must be added in the following order:

{empty}[P1-start_EL_3_0] If running on a
container that supports Jakarta Expression Language 4.0 or higher: The return from
_ExpressionFactory.getStreamELResolver_,
_jakarta.el.StaticFieldELResolver_. [P1-end_EL_3_0]

_jakarta.el.MapELResolver_,
_jakarta.el.ListELResolver_, _jakarta.el.ArrayELResolver_,
_jakarta.el.BeanELResolver_. These actual ELResolver instances must be
added. It is not compliant to simply add other resolvers that preserve
these semantics.

[[a2970]]
===== ScopedAttribute ELResolver

This ELResolver is responsible for doing the
scoped lookup that makes it possible for expressions to pick up anything
stored in the request, session, or application scopes by name.

.Scoped Attribute ELResolver

[width="100%",cols="25%,75%",options="header",]
|===
|ELResorver method
|implementation requirements
| _getValue_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

Use the argument property as the key in a
call to externalContext.getRequestMap().get(). If this returns non-null,
call setPropertyResolved(true) on the argument ELContext and return the
value.

Use the argument property as the key in a
call to facesContext.getViewRoot().getViewMap().get() (accounting for
the potential for null returns safely). If this returns non-null, call
setPropertyResolved(true) on the argument ELContext and return the
value.

Use the argument property as the key in a
call to externalContext.getSessionMap().get(). If this returns non-null,
call setPropertyResolved(true) on the argument ELContext and return the
value.

Use the argument property as the key in a
call to externalContext.getApplicationMap().get(). If this returns
non-null, call setPropertyResolved(true) on the argument ELContext and
return the value.

Otherwise call setPropertyResloved(true) and
return null;

| _getType_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

Otherwise, setPropertyResolved(true) and
return Object.class to indicate that any type is permissable to pass to
a call to setValue().

| _setValue_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

Consult the Maps for the request, session,
and application, in order, looking for an entry under the key property.
If found, replace that entry with argument value. If not found, call
externalContext.getRequestMap().put(property, value).

Call setPropertyResolved(true) and return;

| _isReadOnly_ a|
If base is false, setPropertyResolved(true)
return false;

Otherwise, return false;

| _getFeatureDescriptors_ a|
If base is non-null, return null.

If base is null, return an Iterator of
java.beans.FeatureDescriptor instances for all attributes in all scopes.
The FeatureDescriptor name and shortName is the name of the scoped
attribute. The actual runtime type of the attribute must be stored as
the value of the ELResolver.TYPE attribute. Boolean.TRUE must be set as
the value of the ELResolver.RESOLVABLE_AT_DESIGN_TIME attribute. The
shortDescription must be a suitable description depending on the
implementation. The expert and hidden properties must be false. The
preferred property must be true.

| _getCommonPropertyType_ a|
If base is non-null, return null.

If base is null return String.class.

|===

==== CDI for Expression Language Resolution

If the any of the managed beans in the
application have the _@jakarta.faces.annotation.FacesConfig_ annotation,
the ImplicitObjectELResolver from <<ExpressionLanguageAndManagedBeanFacility.adoc#a2830,
Implicit Object ELResolver for Facelets and Programmatic Access>> is not
present in the chain. Instead, CDI is used to perform Expression Language resolution in
the same manner is in <<ExpressionLanguageAndManagedBeanFacility.adoc#a2832,
ImplicitObjectELResolver for Programmatic Access>> with the following
additional implicit objects:

- _externalContext_

- the current _ExternalContext_ from the
current _FacesContext_


=== Current Expression Evaluation APIs

==== ELResolver

This class is the Jakarta Expression Language’s answer to
Faces’s _VariableResolver_ and _PropertyResolver_. It turns out that
variable resolution can be seen as a special case of property resolution
with the base object being _null_. Please see
_<<ExpressionLanguageAndManagedBeanFacility.adoc#a2634,ELResolver>>_ for more details.

==== ValueExpression

This class is the Jakarta Expression Language’s answer to
Jakarta Faces’s _ValueBinding_. It is the main object oriented abstraction for
an Expression Language expression that results in a value either being retrieved or set.
Please see Chapter 2 of the Jakarta Expression Language Specification, Version
4.0 or higher.

==== MethodExpression

This class is the Jakarta Expression Language’s answer to
Jakarta Faces’s _MethodBinding_. It is the main object oriented abstraction for
an Expression Language expression that results in a method being invoked. Please see
Chapter 2 of the Jakarta Expression Language Specification, Version 4.0 or higher.

==== Expression Evaluation Exceptions

Four exception classes are defined to report
errors related to the evaluation of value exceptions:

- _jakarta.el.ELException_ (which extends
_java.lang.Exception_)—used to report a problem evaluating a value
exception dynamically.

- _MethodNotFoundException_ (which extends
_jakarta.el.ELException_)—used to report that a requested public method
does not exist in the context of evaluation of a method expression.

- _jakarta.el.PropertyNotFoundException_ (which
extends _jakarta.el.ELException_)—used to report that a requested
property does not exist in the context of evaluation of a value
expression.

- _jakarta.el.PropertyNotWriteableException_
(which extends _jakarta.el.ELException_)—used to indicate that the
requested property could not be written to when evaluating the
expression.


=== Deprecated Expression Evaluation APIs

Applications written for version 1.0 and 1.1
of the Faces specification must continue to run in this version of the
specification. This means deprecated APIs. This section describes the
migration story for these APIs that implementations must follow to allow
1.0 and 1.1 based applications to run.

[[a3020]]
==== VariableResolver and the Default VariableResolver

User-provided VariableResolver instances will
still continue to work by virtue of _<<ExpressionLanguageAndManagedBeanFacility.adoc#a2773,
VariableResolver Chain Wrapper>>_. The decorator pattern described in
_<<UsingJSFInWebApplications.adoc#a6336,Delegating Implementation Support>>_
must be supported. Users wishing to affect Expression Language resolution are advised to
author a custom ELResolver instead. These will get picked up as
specified in _<<ExpressionLanguageAndManagedBeanFacility.adoc#a2771,ELResolvers in the
application configuration resources>>_.

The Jakarta Faces implementation must provide a default
_VariableResolver_ implementation that gets the _ELContext_ from the
argument _FacesContext_ and calls _setPropertyResolved(false)_
on it

The _VariableResolver_ chain is no longer
accessible from _Application.getVariableResolver()_. The chain must be
kept in an implementation dependent manner, but accessible to the
ELResolver described in _<<ExpressionLanguageAndManagedBeanFacility.adoc#a2773,
VariableResolver Chain Wrapper>>_.

[[a3025]]
==== PropertyResolver and the Default PropertyResolver

User-provided propertyResolver instances will
still continue to work by virtue of _<<ExpressionLanguageAndManagedBeanFacility.adoc#a2773,
VariableResolver Chain Wrapper>>_. The decorator pattern described in
_<<UsingJSFInWebApplications.adoc#a6336,Delegating Implementation Support>>_
must be supported. Users wishing to affect Expression Language resolution are advised to
author a custom ELResolver instead. These will get picked up as
specified in _<<ExpressionLanguageAndManagedBeanFacility.adoc#a2771,ELResolvers in the
application configuration resources>>_.

The Jakarta Faces implementation must provide a default
_propertyResolver_ implementation that gets the _ELContext_ from the
argument _FacesContext_ and calls _setPropertyResolved(false)_ on it.

The _PropertyResolver_ chain is no longer
accessible from _Application.getpropertyResolver()_. The chain must be
kept in an implementation dependent manner, but accessible to to the
ELResolver described in _<<ExpressionLanguageAndManagedBeanFacility.adoc#a2798,
PropertyResolver Chain Wrapper>>_.

[[a3029]]
==== ValueBinding

The _ValueBinding_ class encapsulates the
actual evaluation of a value binding. Instances of _ValueBinding_ for
specific references are acquired from the _Application_ instance by
calling the _createValueBinding_ method (see
<<ApplicationIntegration.adoc#a4179,Acquiring ValueBinding Instances>>).

[source,java]
----
public Object getValue(FacesContext context)
    throws EvaluationException, PropertyNotFoundException;
----

Evaluate the value binding used to create
this _ValueBinding_ instance, relative to the specified _FacesContext_,
and return the referenced value.

[source,java]
----
public void setValue(FacesContext context, Object value)
    throws EvaluationException, PropertyNotFoundException;
----

Evaluate the value binding used to create
this _ValueBinding_ instance, relative to the specified _FacesContext_,
and update the referenced value to the specified new value.

[source,java]
----
public boolean isReadOnly(FacesContext context)
    throws EvaluationException, PropertyNotFoundException;
----

Evaluate the value binding used to create
this _ValueBinding_ instance, relative to the specified _FacesContext_,
and return _true_ if the corresponding property is known to be
immutable. Otherwise, return _false_.

[source,java]
----
public Class getType(FacesContext context)
    throws EvaluationException, PropertyNotFoundException;
----

Evaluate the value binding used to create
this _ValueBinding_ instance, relative to the specified _FacesContext_,
and return the _Class_ that represents the data type of the referenced
value, if it can be determined. Otherwise, return _null_.

[[a3039]]
==== MethodBinding

The _MethodBinding_ class encapsulates the
actual evaluation of a method binding. Instances of _MethodBinding_ for
specific references are acquired from the _Application_ instance by
calling the _createMethodBinding()_ method. Note that instances of
_MethodBinding_ are immutable, and contain no references to a
_FacesContext_ (which is passed in as a parameter when the reference
binding is evaluated).

[source,java]
----
public Object invoke(FacesContext context, Object params[])
    throws EvaluationException, MethodNotFoundException;
----

Evaluate the method binding (see
<<ExpressionLanguageAndManagedBeanFacility.adoc#a2403,MethodExpression Syntax and Semantics>>)
and call the identified method, passing the specified parameters. Return
any value returned by the invoked method, or return _null_ if the
invoked method is of type _void_.

[source,java]
----
public Class getType(FacesContext context) throws MethodNotFoundException;
----

Evaluate the method binding (see
<<ExpressionLanguageAndManagedBeanFacility.adoc#a2403,MethodExpression Syntax and Semantics>>)
and return the _Class_ representing the return type of the identified
method. If this method is of type _void_, return _null_ instead.

==== Expression Evaluation Exceptions

Four exception classes are defined to report
errors related to the evaluation of value exceptions [Note that these
exceptions are deprecated]:

- _EvaluationException_ (which extends
_FacesException_)—used to report a problem evaluating a value exception
dynamically.

- _MethodNotFoundException_ (which extends
_EvaluationException_)—used to report that a requested public method
does not exist in the context of evaluation of a method expression.

- _PropertyNotFoundException_ (which extends
_EvaluationException_)—used to report that a requested property does
not exist in the context of evaluation of a value expression.

- _ReferenceSyntaxException_ (which extends
_EvaluationException_)—used to report a syntax error in a value
exception.


=== CDI Integration

Jakarta Faces must run in a container that supports CDI version 3.0 or higher. This requirement
allows CDI to provide all the functionality of the managed bean facility
from <<ExpressionLanguageAndManagedBeanFacility.adoc#a2406,The Managed Bean Facility>> and
<<ExpressionLanguageAndManagedBeanFacility.adoc#a2536,Managed Bean Annotations>> but in a
better integrated way with the rest of the Jakarta EE platform. Delegating
these features to CDI allows them to evolve independently of Jakarta Faces. The
remainder of this section specifies some details of CDI integration
pertinent to Jakarta Faces.

[[a3054]]
==== Jakarta Faces Objects Valid for @Inject Injection

It must be possible to inject the following
Jakarta Faces objects into other objects using _@Inject_.

.Maps Returned by Various Jakarta Faces Accessors

The annotations in package
_jakarta.faces.annotation_ are used to cause _@Inject_ injection of the
corresponding _Map_ into a field. Generics may be used.

.Jakarta Faces Objects

It must be possible to _@Inject_ the following Jakarta Faces and Jakarta EE objects into CDI beans.

- _jakarta.faces.application.ResourceHandler_

- jakarta.faces.context.ExternalContext

- jakarta.faces.context.FacesContext

- jakarta.faces.context.Flash

- _jakarta.servlet.http.HttpSession_

.Support for Injection into Jakarta Faces Managed Objects

It must be possible to use _@Inject_ when
specifying the following kinds of Jakarta Faces managed objects.

- Validators declared with
_@jakarta.faces.validator.FacesValidator(managed=”true”)_

- Converters declared with
_@jakarta.faces.convert.FacesConverter(managed=”true”)_

- FacesBehaviors declared with
_@jakarta.faces.component.behavior.FacesBehavior(managed=”true”)_

[[a3070]]
==== Expression Language Resolution

The following implicit objects must be
resolved using CDI

- application

- cc

- component

- facesContext

- flash

- flowScope

- header

- headerValues

- initParam

- param

- paramValues

- session

- view

- viewScope


